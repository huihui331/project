<template>
  <div>
    <input type="file" @change="uploadPicture" ref="uploadInputRef" />
    <img v-if="decorationImgSrc" :src="decorationImgSrc" alt="Uploaded Image" />
  </div>
</template>

<script>
  import { ref } from 'vue';
  import { usePictureStore } from './stores/pictureStore'; // 假设你的Pinia store在这里  

  export default {
    setup() {
      const uploadInputRef = ref(null);
      const pictureStore = usePictureStore();
      const decorationImgSrc = ref(null);

      function uploadPicture(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            decorationImgSrc.value = e.target.result as string;
            pictureStore.decorationImgsHidden = false;
            pictureStore.decorationImgSrc = decorationImgSrc.value;
          };
          reader.readAsDataURL(file);
        }
      }

      // 注意：这里我们不需要在beforeUnmount中清理decorationImgSrc，因为它是一个响应式引用，Vue会自动处理。  
      // 但是，如果你直接在store中存储了一个由FileReader创建的URL，那么你应该在适当的时机（比如当图片被替换或组件卸载时）调用URL.revokeObjectURL来释放它。  

      return {
        uploadInputRef,
        decorationImgSrc, // 注意：这里我们实际上没有直接在模板中使用这个引用，但它可以用于其他逻辑。  
        // 我们直接在模板中使用了pictureStore的状态。  
      };
    },
  };  
</script>